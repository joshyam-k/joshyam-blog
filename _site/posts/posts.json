[
  {
    "path": "posts/welcome/",
    "title": "Spatial interpolation using polynomial regression in R",
    "description": "Using 5-fold CV to determine the best polynomial degree for modeling precipitation data\nin California.",
    "author": [
      {
        "name": "Josh Yamamoto",
        "url": "https://joshyam-blog.netlify.app"
      }
    ],
    "date": "2021-03-14",
    "categories": [],
    "contents": "\nIn this post, I’ll walk through using polynomial regression for spatial interpolation using Precipitation data from California.\nData Prep and Motivation\nWe’ll start by loading in all of the necessary packages.\n\n\nlibrary(tidyverse)\nlibrary(raster)\nlibrary(rspatial)\nlibrary(dismo)\nlibrary(sf)\n\n\n\nNext we’ll load in the data that we’ll need, and then convert it to a SpatialPointsDataFrame object.\n\n\nrain_data_raw <- sp_data('precipitation')\nrain_data_raw$prec <- rowSums(rain_data_raw[, c(6:17)])\nCA <- sp_data(\"counties\")\n\nrain_sp <- SpatialPoints(rain_data_raw[,4:3], proj4string=CRS(\"+proj=longlat +datum=NAD83\"))\nrain_sp <- SpatialPointsDataFrame(rain_sp, rain_data_raw)\n\n\n\nWe’d like to use a specific coordinate reference system since we’re only looking at California, and so we’ll specify it and then apply it to our data. Don’t worry about the cata and ca lines, they’re just creating a california boundary object for us, and we wont use them until the very end.\n\n\nnew_crs <- CRS(\"+proj=aea +lat_1=34 +lat_2=40.5 +lat_0=0 +lon_0=-120 +x_0=0 +y_0=-4000000\n               +datum=NAD83 +units=m +ellps=GRS80 +towgs84=0,0,0\")\n\nrain_new <- spTransform(rain_sp, new_crs)\n\ncata <- spTransform(CA, new_crs)\nca <- aggregate(cata)\n\n\n\nFinally for modeling we’d like our precipitation data to be a data frame with coordinates and precipitation levels.\n\n\nrain <- as.data.frame(rain_new$prec)\ncolnames(rain) <- c(\"prec\")\n\nrain$X <- coordinates(rain_new)[,1]\nrain$Y <- coordinates(rain_new)[,2]\n\n\n\nSo what’s the end goal here, and what is spatial interpolation?\nWell we have precipitation data for individual points across California:\n\n\nca_sf <- st_as_sf(ca)\n\nggplot() +\n  geom_sf(data = ca_sf) + \n  geom_point(data = rain, aes(x = X, y = Y, color = prec)) +\n  coord_sf() +\n  theme_void()\n\n\n\n\nBut what if we’d like to predict precipitation levels for every single location in California? One (not very good) option is to fit a polynomial regression to the existing points and then use that model to predict the precipitation levels for the entire field.\nSupplementary functions\nWe’ll evaluate our model using the residual mean squared error or RMSE, so we’ll write a quick function that can compute that for us:\n\n\nRMSE <- function(observed, predicted) {\n  sqrt(mean((predicted - observed)^2, na.rm=TRUE))\n}\n\n\n\nAdditionally we’ll be trying varying degrees for our polynomial regression so it’ll be nice to have a function that can make that process simpler for us. For this exercise in spatial interpolation we’re going to be using every interaction term and since that requires an \\(n - 1\\) argument we have to specify the special case for when \\(n = 1\\). Notice how specialized to this individual exercise this function is. We know that the data we feed in will have a “prec” column and that X and Y will always be in our dataset.\n\n\npoly_mod <- function(n, data){\n  if (n == 1){\n    lm(data$prec ~ X + Y, data)\n  } else {\n    lm(data$prec ~ poly(X, n) + poly(Y,n) + poly(X, n - 1):poly(Y, n - 1), data)\n  }\n}\n\n\n\nA 5-fold CV function specific to this data\nSo now we have all the tools to write a function that will perform cross validation for us. The function looks a little confusing but it’s just doing the following 5 simple steps\nspecify which indices belong to which fold\ncreate an empty vector to be filled with rmse values\nfor each fold fit the model to the training data, and then apply the model to the test data\ncalculate the rmse and add it to our empty vector\nafter all folds have been used, take the output mean of the 5 rmse values\nNotice our function has just one argument, n and this specifies the degree of our polynomial.\n\n\nk_fold_func <- function(n){\n  \n  folds <- kfold(nrow(rain_new))\n  rmse <- rep(NA, 5)\n  \n  for (i in 1:5) {\n    test <- rain[folds == i, ]\n    train <- rain[folds != i, ]\n    mod <- poly_mod(n, data = train)\n    preds <- predict(mod, newdata = test)\n  \n    rmse[i] <- RMSE(preds, test$prec)\n  }\n  mean(rmse)\n}\n\n\n\nPutting our functions to use!\nNow we can finally fit some models and use our cross-validation function. We’ll try a range from 1-10 for our different polynomial degrees. It’s important to set a seed here because our folds are randomly created. We’ll use purrr::map to apply our function to our range of n’s\n\n\nset.seed(27)\nrange <- 1:10\n\nrmse_vals <- range %>% \n  purrr::map(k_fold_func)\n\n\n\nWe’ll find the rmse of a null model that we can compare our polynomial regression to:\n\n\nnull <- RMSE(mean(rain_sp$prec), rain_sp$prec)\n\n\n\nAnd now we’ll turn rmse_vals into a data frame and then visualize it:\n\n\nrmse_df <- as.data.frame(do.call(rbind, rmse_vals)) \n\ncolnames(rmse_df) <- c(\"rmse\")\n\nrmse_df$n <- 1:10\n\nrmse_df %>% \n  ggplot(aes(x = factor(n), y = rmse, group = 1)) +\n  geom_point(size = 3, color = \"cyan4\") +\n  geom_line() +\n  geom_hline(yintercept = null, size = 1.5, alpha = 0.6, color = \"midnightblue\") +\n  annotate(\"text\", x = 1.5, y = 470, label = \"Null\") +\n  theme_minimal() +\n  labs(\n    x = \"Polynomial Degree\",\n    y = \"RMSE\"\n  )\n\n\n\n\nIt looks like we hit a sweet spot right around \\(n = 5\\) and it looks like anything above \\(n = 7\\) is when we start to severely over-fit. So now we’ll use our polynomial of degree 5 to perform spatial interpolation for California Precipitation.\nInterpolation\nEssentially all we’re doing here is fitting our model, creating a grid object across which we can make predictions, and then adding those predictions to the grid.\n\n\nbest_mod <- poly_mod(5, rain)\n\ngrid <- as.data.frame(spsample(rain_new, \"regular\", n = 50000))\nnames(grid) <- c(\"X\", \"Y\")\ncoordinates(grid) <- c(\"X\", \"Y\")\ngridded(grid) <- TRUE\nfullgrid(grid) <- TRUE \n\npredictions <- SpatialGridDataFrame(grid, data.frame(var1.pred = predict(best_mod, newdata = grid))) \n\n\n\nFinally we’ll turn our grid into a raster and trim it so that it is contained inside of California’s boundaries and plot it!\n\n\nraster_preds <- raster(predictions)\ntrimmed_raster <- mask(raster_preds, ca)\n\nplot(trimmed_raster)\n\n\n\n\nWhen we compare this to our original plot of just points we can see that it follows similar trends, with higher precipitation levels being characteristic of northern California. Furthermore since our 5th degree polynomial substantially beats out the null model, there is also some merit in this approach, but ultimately methods like proximity polygons and inverse distance weighting will likely perform better.\n\n\n\n",
    "preview": "posts/welcome/welcome_files/figure-html5/unnamed-chunk-4-1.png",
    "last_modified": "2021-03-14T13:39:25-07:00",
    "input_file": "welcome.utf8.md"
  }
]
